/*
 * Copyright (C) 2019 Giulio Purgatorio <giulio.purgatorio93 at gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package gui;

import beans.Drone;
import core.Configurations;
import core.ExtendedJLabel;
import core.Location;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyVetoException;
import java.beans.VetoableChangeListener;
import java.beans.VetoableChangeSupport;
import java.util.Random;

/**
 * The GUIClass for the DronesPlus optional assignment.
 * "In the new project make loc a vetoable property of Drone, and 
 * implement it in such a way that a veto during takeOff moves the 
 * drone to position (0, 0) whereas a veto in any other moment just 
 * leaves the location unchanged. 
 * Finally, register the JFrame of the application of Exercise 2b as 
 * a VetoableChangeListener: the JFrame must block any attempt 
 * of the drones to "escape" pnlDrones."
 *
 * @author Giulio Purgatorio <giulio.purgatorio93 at gmail.com>
 */
public class GUIDrones extends javax.swing.JFrame implements VetoableChangeListener {

    // Used to fireVetos about the drones escaping out of bounds
    private final VetoableChangeSupport escapeDrone;
    // Used for the vetoable change support
    private final GUIDrones reference;
    
    /**
     * Creates new form GUIDrones.
     */
    public GUIDrones() {
        initComponents();
        // Netbeans starts the GUI with a LayoutManager (GroupLayout)
        // We remove it in order to be able to move labels around as needed
        removeLayout();
        
        // This reference is used to add the JFrame as a listener for each drone
        reference = this;
        
        // This will be used to block the out of bounds movement of each drone
        escapeDrone = new VetoableChangeSupport(this);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        pnlDrones = new javax.swing.JPanel();
        btnAdd = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Drones-Purgatorio");

        pnlDrones.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        pnlDrones.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));

        javax.swing.GroupLayout pnlDronesLayout = new javax.swing.GroupLayout(pnlDrones);
        pnlDrones.setLayout(pnlDronesLayout);
        pnlDronesLayout.setHorizontalGroup(
            pnlDronesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 448, Short.MAX_VALUE)
        );
        pnlDronesLayout.setVerticalGroup(
            pnlDronesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 448, Short.MAX_VALUE)
        );

        btnAdd.setText("Add Drone");
        btnAdd.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                btnAddMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(pnlDrones, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnAdd)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(pnlDrones, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGap(222, 222, 222)
                .addComponent(btnAdd)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pnlDrones.getAccessibleContext().setAccessibleName("");
        pnlDrones.getAccessibleContext().setAccessibleDescription("");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Sets the LayoutManager to null, the pnlDrones size and visibility.
     */
    private void removeLayout() {
        getContentPane().setLayout(null);
        pnlDrones.setBounds(10, 10, Configurations.PANEL_WIDTH, Configurations.PANEL_HEIGHT);
        pnlDrones.setVisible(true);
    }
    
    /**
     * Repaints the panel pnlDrones.
     */
    public static void updateGUI() {
        pnlDrones.repaint();
    }
    
    private void btnAddMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnAddMouseClicked
            
        // Generates the two random values to represent the position
        Random r = new Random();
        // The *1.5 is there in order to allow some of the Drones to spawn out of bounds
        double x = r.nextDouble()*Configurations.SPAWN_AREA_X*1.5;
        double y = r.nextDouble()*Configurations.SPAWN_AREA_Y*1.5;
        
        // The location where the Drone will spawn
        Location loc = new Location(x, y);
        // Creates a new Drone object, called newDrone as requested
        Drone newDrone = new Drone(loc);
        
        // The extended label that will be shown in the GUI
        ExtendedJLabel l = new ExtendedJLabel();
        
        // Puts the label in the same location of the drone
        l.setBounds((int)loc.getX(), (int)loc.getY(), Configurations.LABEL_WIDTH, Configurations.LABEL_HEIGHT);
        
        // Sets its text accordingly to the assignment request
        l.setText(loc);
        
        // Adds the label as a listener to the drone for both the Location property and the Flying property
        newDrone.addVetoableChangeListener(l);
        /* Debug purpose: if we want to see a (gray) colored rectangle instead of just the colored text
        l.setOpaque(true);
        l.setBackground(java.awt.Color.GRAY);
        */
        // This is an addition to the previous exercise to allow the vetoEvents between the drone and the JFrame
        newDrone.addVetoableChangeListener(reference);
        // Sets the label as visible in order to show it in the Panel
        l.setVisible(true);
        
        // Adds a MouseListener, in order to start/stop the drone
        l.addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    newDrone.land();            
                }
            }  
        );
        
        // Adds the label to the JPanel, so that it can be shown
        pnlDrones.add(l);
        
        // Same as the previous addition, but in the opposite order
        this.addVetoableChangeListener(l);
        
        // Calls a repaint of the panel, since there's an update to show
        updateGUI();
        
    }//GEN-LAST:event_btnAddMouseClicked

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUIDrones.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        
        //</editor-fold>
        //</editor-fold>
        
        // Removed the check so that drones can spawn out of bounds in order to fire vetos

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new GUIDrones().setVisible(true);
        });
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnAdd;
    private static javax.swing.JPanel pnlDrones;
    // End of variables declaration//GEN-END:variables

    /**
     * The vetoableChange method from the VetoableChangeListener:
     * it will check for the "loc" updates from each drone and check that
     * it's inside the valid bounds, limiting it by firing its veto if needed.
     * 
     * @param pce the PropertyChangeEvent, only the "loc" case is considered
     * @throws PropertyVetoException 
     */
    @Override
    public void vetoableChange(PropertyChangeEvent pce) throws PropertyVetoException {
        switch(pce.getPropertyName()) {
            case "loc":
                // Get the new location 
                Location loc = (Location) pce.getNewValue();
                
                // Check if it's out of the bounds
                if(loc.getX() < 0 || loc.getX() > Configurations.SPAWN_AREA_X ||
                    loc.getY() < 0 || loc.getY() > Configurations.SPAWN_AREA_Y) {
                
                    // If it's out of them, then get the closest valid location..
                    Location validLoc = getClosestValidLoc(loc);    

                    // .. and fire it: "the JFrame must block any attempt of the drones to "escape" pnlDrones"
                    escapeDrone.fireVetoableChange("esc", pce.getOldValue(), validLoc);   
                }
                break;
            default:
                break;
        }
    }

    private void addVetoableChangeListener(ExtendedJLabel l) {
        escapeDrone.addVetoableChangeListener(l);
    }
    
    /**
     * Returns the closest in bound location to the given one.
     * 
     * @param notValidLoc the (maybe) not valid location
     * @return a valid location, which can be the given one if it was not out of bounds.
     */
    private Location getClosestValidLoc(Location notValidLoc) {
        int x = (int) notValidLoc.getX();
        int y = (int) notValidLoc.getY();
        
        if(x > Configurations.SPAWN_AREA_X)
            x = Configurations.SPAWN_AREA_X;
        else if (x < 0) 
            x = 0;
        if(y > Configurations.SPAWN_AREA_Y)
            y = Configurations.SPAWN_AREA_Y;
        else if (y < 0)
            y = 0;
        
        return (new Location(x, y));
    }
}
